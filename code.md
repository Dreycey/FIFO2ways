/*
 * cbfifo.h - a fixed-size FIFO implemented via a circular buffer
 * 
 * Author: Howdy Pierce, howdy.pierce@colorado.edu
 * 
 * DO NOT EDIT THIS FILE: You should check this file into your repo
 * exactly as it was delivered to you.
 */

#ifndef _CBFIFO_H_
#define _CBFIFO_H_

#include <stdlib.h>  // for size_t

/*
 * Enqueues data onto the FIFO, up to the limit of the available FIFO
 * capacity.
 *
 * Parameters:
 *   buf      Pointer to the data
 *   nbyte    Max number of bytes to enqueue
 * 
 * Returns:
 *   The number of bytes actually enqueued, which could be 0. In case
 * of an error, returns (size_t) -1.
 */
size_t cbfifo_enqueue(void *buf, size_t nbyte);

/* 
 * White-box testing function 
 *
 * White box testing that allows for lookng inside the Q
 */
int validate_dbfifo();

/*
 * Attempts to remove ("dequeue") up to nbyte bytes of data from the
 * FIFO. Removed data will be copied into the buffer pointed to by buf.
 *
 * Parameters:
 *   buf      Destination for the dequeued data
 *   nbyte    Bytes of data requested
 * 
 * Returns:
 *   The number of bytes actually copied, which will be between 0 and
 * nbyte. 
 * 
 * To further explain the behavior: If the FIFO's current length is 24
 * bytes, and the caller requests 30 bytes, cbfifo_dequeue should
 * return the 24 bytes it has, and the new FIFO length will be 0. If
 * the FIFO is empty (current length is 0 bytes), a request to dequeue
 * any number of bytes will result in a return of 0 from
 * cbfifo_dequeue.
 */
size_t cbfifo_dequeue(void *buf, size_t nbyte);


/*
 * Returns the number of bytes currently on the FIFO. 
 *
 * Parameters:
 *   none
 * 
 * Returns:
 *   Number of bytes currently available to be dequeued from the FIFO
 */
size_t cbfifo_length();


/*
 * Returns the FIFO's capacity
 *
 * Parameters:
 *   none
 * 
 * Returns:
 *   The capacity, in bytes, for the FIFO
 */
size_t cbfifo_capacity();


#endif // _CBFIFO_H_
/*
 * llfifo.h - a dynamically-growing FIFO
 * 
 * Author: Howdy Pierce, howdy.pierce@colorado.edu
 * 
 * DO NOT EDIT THIS FILE: You should check this file into your repo
 * exactly as it was delivered to you.
 */

#ifndef _LLFIFO_H_
#define _LLFIFO_H_


/* 
 * The llfifo's main data structure. 
 *
 * Defined here as an incomplete type, in order to hide the
 * implementation from the user. You will need to define this struct
 * in your .c file.
 */
typedef struct llfifo_s llfifo_t;

/* 
 * White-box testing function 
 *
 * White box testing that allows for lookng inside the Q
 */
int validate_llfifo(llfifo_t* llQ);

/*
 * Creates and initializes the FIFO
 *
 * Parameters:
 *   capacity  the initial size of the fifo, in number of elements. 
 *             Valid values are in the range of 0 to the limits of memory
 * 
 * Returns: A pointer to a newly-created llfifo_t instance, or NULL in
 *   case of an error.
 */
llfifo_t *llfifo_create(int capacity);


/*
 * Enqueues an element onto the FIFO, growing the FIFO by adding
 * additional elements, if necessary
 *
 * Parameters:
 *   fifo    The fifo in question
 *   element The element to enqueue, which cannot be NULL
 * 
 * Returns:
 *   The new length of the FIFO on success, -1 on failure. It is an error to attempt 
 * to enqueue the NULL pointer.
 */
int llfifo_enqueue(llfifo_t *fifo, void *element);


/*
 * Removes ("dequeues") an element from the FIFO, and returns it
 *
 * Parameters:
 *   fifo  The fifo in question
 * 
 * Returns:
 *   The dequeued element, or NULL if the FIFO was empty
 */
void *llfifo_dequeue(llfifo_t *fifo);


/*
 * Returns the number of elements currently on the FIFO. 
 *
 * Parameters:
 *   fifo  The fifo in question
 * 
 * Returns:
 *   The number of elements currently on the FIFO
 */
int llfifo_length(llfifo_t *fifo);


/*
 * Returns the FIFO's current capacity
 *
 * Parameters:
 *   fifo  The fifo in question
 * 
 * Returns:
 *   The current capacity, in number of elements, for the FIFO
 */
int llfifo_capacity(llfifo_t *fifo);


/*
 * Teardown function: Frees all dynamically allocated
 * memory. After calling this function, the fifo should not be used
 * again!
 *
 * Parameters:
 *   fifo  The fifo in question
 * 
 * Returns: none
 */
void llfifo_destroy(llfifo_t *fifo);

#endif // _LLFIFO_H_


/*
 * Tests the Circular Buffer FIFO 
 *
 * Parameters:
 *   N/A
 * 
 * Returns:
 *   0 upon success
 */
int test_cbfifo();


/*
 * Tests the Linked List FIFO 
 *
 * Parameters:
 *   N/A
 * 
 * Returns:
 *   0 upon success
 */
int test_llfifo();


#include "cbfifo.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#define CB_SIZE 128 // size of buffer


/* 
 * circular buffer
 * from Ch. 6 White
 */
struct sCircularBuffer {
  uint8_t array[CB_SIZE];    // must be a power of two
  int read;    // holds current read position: 0 to (CB_SIZE-1)
  int write;   // holds current write position: 0 to (CB_SIZE-1)
  int length; // Default is 0, changed to true once full.
};

/* 
 * Creating a typedef for the circular buffer
 */
typedef struct sCircularBuffer tCircularBuffer;

/* 
 * Instantiating static ciric buff 
 */
static tCircularBuffer cb;

size_t cbfifo_enqueue(void *buf, size_t nbyte) {
    if (nbyte < 0) {return (CB_SIZE-1);}
    if (!buf) {return (CB_SIZE-1);}

    int num_bytes_added = 0;
    uint8_t * ptr_to_buffer = buf;
    for (int i=0; i < nbyte; i++){
        if (cb.length >= CB_SIZE) {return num_bytes_added;}
        cb.array[cb.write] = (*(uint8_t *)ptr_to_buffer) & (0xFF);
        cb.length++;
        num_bytes_added++;
        ptr_to_buffer++;

        // update the write pointer - resets to zero once == CB_SIZE
        cb.write = (cb.write + 1) & (CB_SIZE - 1);
    }
    return num_bytes_added;
}

size_t cbfifo_dequeue(void *buf, size_t nbyte) {

    uint8_t * ptr_cpy = (uint8_t *)buf;
    int num_bytes_removed = 0;
    if (cb.length <= 0) {return num_bytes_removed;}
    for (int i=0; i<nbyte; i++){
        if (cb.length <= 0) {return num_bytes_removed;} // if empty, return
        ptr_cpy[i] = cb.array[cb.read];
        cb.length--;
        num_bytes_removed++;

        // update the write pointer - resets to zero once == CB_SIZE
        cb.read= (cb.read + 1) & (CB_SIZE - 1);
    }
    return num_bytes_removed;
}

int validate_dbfifo() {
    int read_cpy = cb.read;
    printf("\n\n CBFIFO Validation \n");
    printf("\t Read ptr: %d Write ptr: %d \n", cb.read, cb.write);
    printf("\t length: %ld capacity: %ld \n", cbfifo_length(), cbfifo_capacity());
    for (int index=0; index < cbfifo_length(); index++) {
        printf("\t value at array index: %d is %d \n", read_cpy, cb.array[read_cpy]);
        read_cpy = (read_cpy + 1) & (CB_SIZE - 1);
    }
    return 0;
}

size_t cbfifo_capacity() {
    return CB_SIZE;
}

size_t cbfifo_length() {
    return cb.length;
}#include "llfifo.h"
#include <stdio.h>
#include <stdlib.h>

/* 
 * node - individual node in the linked list
 */
struct Node {
    void* data;
    struct Node* next;
};

/* 
 * llfifo_s - the definition for the linked list structure
 */
struct llfifo_s {
    int initial_capacity;
    int capacity;
    int length;
    struct Node* head;
};

llfifo_t *llfifo_create(int capacity) {
    if (capacity < 0) {return NULL;}

    llfifo_t* llQueue = (llfifo_t*)malloc(sizeof(llfifo_t));
    if (llQueue == NULL) {return NULL;} // If Null ptr returned
    llQueue->capacity = capacity;
    llQueue->initial_capacity = capacity;
    llQueue->length = 0;
    llQueue->head = (struct Node *)malloc(sizeof(struct Node) * (capacity)); //init size
    //if (llQueue->head == NULL) {return NULL;} // If Null ptr returned

    /* Build initial Linked List*/
    int counter = 1;
    struct Node* ptr = llQueue->head;
    struct Node* prev_node = llQueue->head;
    prev_node->next = NULL;
    while (counter < capacity) {
        struct Node* curr_node = &ptr[counter];
        prev_node->next = curr_node;
        prev_node = curr_node;
        prev_node->next = NULL;
        counter++;
    }
    /* Build initial Linked List*/

    return llQueue;
}

int llfifo_enqueue(llfifo_t *fifo, void *element) {
    if (element == NULL) {return -1;}

    struct Node* node = fifo->head;
    if (fifo->capacity > fifo->length) {
        int counter = 0;
        while (counter < fifo->length) {
            node = node->next;
            counter++;
        }
        node->data = element; /* TODO: How to save element? just a pointer? */
        fifo->length++;
    }
    else {
        struct Node* curr_node = (struct Node *)malloc(sizeof(struct Node)); 
        // add new node to end of linked list
        while (node->next != NULL) {
            node = node->next;
        }
        node->next = curr_node;
        curr_node->next = NULL;
        curr_node->data = element; /* TODO: How to save element? just a pointer? */
        fifo->length++;
        fifo->capacity++;
    }
    return 0;
}

void *llfifo_dequeue(llfifo_t *fifo) {
    if (fifo->length == 0) {return NULL;} // if empty
    struct Node* prev_node;
    struct Node* node = fifo->head;
    void * result_ptr = node->data; // head is oldest data
    /* SHIFT UP LINKED LIST O(N) */ 
    while (node->next != NULL){
        prev_node = node;
        node = node->next;
        prev_node->data = node->data;
    }
    if (node->next == NULL) {node->data = NULL;} // last must be NULL on dequeue
    fifo->length--;
    return result_ptr;  
}

int llfifo_length(llfifo_t *fifo) {
    return fifo->length;
}

int llfifo_capacity(llfifo_t *fifo) {
    return fifo->capacity;
}

void llfifo_destroy(llfifo_t *fifo) {
    struct Node* node = fifo->head;
    struct Node* prev_node;
    int count = 0;
    while (node != NULL){
        prev_node = node;
        node = node->next;
        if (count > fifo->initial_capacity) {
            free(prev_node);
        }
        count++;
    }
    if (fifo->head != NULL)
        free(fifo->head); // Free initial cacpacity allocted last
    free(fifo);
}

int validate_llfifo(llfifo_t* llQ){
    printf("\n\nINFORMATION ON THE LLFIFO \n");
    printf("\t 1. Here is the current length: %d \n", llQ->length);
    printf("\t 2. Here is the current capacity: %d \n", llQ->capacity);
    int node_count = 0;
    struct Node* node = llQ->head;
    while (node != NULL){
        printf("\t Data at node %d is %p \n", node_count, node->data);
        node = node->next;
        node_count += 1;
    }
    return 0;
}

#include "test_cbfifo.h"
#include "cbfifo.h"
#include <stdio.h>
#include <assert.h>



int test_cbfifo() {
    printf("\n\n Testing CBFIFO \n\n");

    // Testing my name
    char val_to_store[] = {'D', 'r', 'e', 'y', 'c', 'e', 'y'}; 
    size_t number_added = cbfifo_enqueue(val_to_store, sizeof(val_to_store));
    printf("number added: %ld \n", number_added);
    char my_name[sizeof(val_to_store)+1];
    cbfifo_dequeue(my_name, sizeof(val_to_store));
    my_name[sizeof(val_to_store)+1] = '\0';
    printf("NAME POINTER: %p \n", my_name);
    printf("My name, dequed, is: %s \n", my_name);
    validate_dbfifo();

    // testing a dequeue with an empty queue
    assert(cbfifo_dequeue(my_name, sizeof(val_to_store)) == 0);

    // Add 128 (max) PLUS ONE
    char single_char[] = {'A'};
    int max_size = 128;
    for (int i=1; i<=max_size; i++) {
        number_added = cbfifo_enqueue(single_char, 1);
    }
    number_added = cbfifo_enqueue(single_char, 1);
    printf("number added: %ld \n", number_added);
    assert(number_added == 0); // should be one less than max

    // return 0 if all pass
    return 0;
}#include "test_llfifo.h"
#include "llfifo.h"
#include <stdio.h>


int test_llfifo(){
    printf("\n\n Testing LLFIFO \n\n");

    // capacity of size  0
    int cap_1 = 0;
    llfifo_t* llQ = llfifo_create(cap_1);
    validate_llfifo(llQ);
    llfifo_destroy(llQ);
    //validate_llfifo(llQ);

    // capacity of size  10
    int cap_2 = 5;
    llfifo_t* llQ2 = llfifo_create(cap_2);
    validate_llfifo(llQ2);
    llfifo_destroy(llQ2);
    //validate_llfifo(llQ2);

    // 2 QUEUES
    double value = 500000000000000;
    double* pvalue = &value;
    llfifo_t* llQ3 = llfifo_create(cap_2);
    llfifo_t* llQ4 = llfifo_create(cap_2);
    llfifo_enqueue(llQ3, pvalue);
    validate_llfifo(llQ4);
    llfifo_enqueue(llQ4, pvalue);
    validate_llfifo(llQ4);
    llfifo_enqueue(llQ4, pvalue);
    validate_llfifo(llQ4);
    llfifo_destroy(llQ3);
    llfifo_destroy(llQ4);

    // capacity of size  1
    int cap_3 = 1;
    llfifo_t* llQ5 = llfifo_create(cap_3);
    validate_llfifo(llQ5);
    llfifo_destroy(llQ5);

    // capacity of size  20
    int cap_4 = 20;
    llfifo_t* llQ6 = llfifo_create(cap_4);
    validate_llfifo(llQ6);
    llfifo_destroy(llQ6);

    // return 0 upon success
    return 0;
}